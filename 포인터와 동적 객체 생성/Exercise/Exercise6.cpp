//값에 의한 호출과 참조에 의한 호출 효율성 비교

//값에 의한 호출
bool isEqual(Point p1. Point p2){
 return((p1.getX() == p2.getX()) && (p1.getY()==p2.getY()));
}

//참조에 의한 호출
bool isEqual(Point *p1. Point *p2){
 return((p1->getX() == p2->getX()) && (p1->getY()==p2->getY()));
}

/*
C++에서 함수의 인자를 전달하는 방식에는 주로 값에 의한 호출 (call by value)과 참조에 의한 호출 (call by reference)이 사용됩니다. 
어떤 방식이 더 효율적인지는 전달하려는 데이터의 종류와 크기, 그리고 함수에서 이 데이터를 어떻게 사용하는지에 따라 다릅니다.

값에 의한 호출 (Call by Value): 이 방식은 함수가 인자로 받은 값을 복사하여 새로운 메모리 공간에 저장합니다. 
따라서 원본 데이터가 변경되지 않습니다. 그러나 큰 객체를 복사하는 경우 시간과 메모리 사용량이 많아질 수 있어 비효율적일 수 있습니다.

참조에 의한 호출 (Call by Reference): 이 방식은 원본 데이터의 메모리 주소를 전달하여 복사 비용을 줄입니다. 
따라서 큰 객체를 전달할 때 효유적입니다. 그러나 참조된 원본 데이터가 함수 내에서 변경되면 원래 변수의 값도 변하므로 주의해야 합니다.

따라서, 작은 크기의 기본형 타입들(int, char, double 등)을 다룰 때는 값에 의한 호출을 사용하고, 
크기가 큰 클래스나 구조체 등을 다룰 때는 참조 혹은 const 참조(call by const reference)를 사용하는 것이 일반적으로 권장됩니다.

const 참조(call by const reference)는 창조자체가 상수화되어 함수 내부에서 해당 매개변수의 값을 바꿀 수 없게 하는 것으로, 
대용량 객체들을 안전하게 넘긴다거나 하려 할 때 유용합니다.

두 코드 모두 `Point` 객체의 동일성을 비교하는 함수를 정의하고 있습니다. 
하지만 두 코드는 인자를 받는 방식이 다릅니다. 
첫 번째 코드는 값에 의한 호출 (call by value)을 사용하고,
두 번째 코드는 포인터를 통한 참조에 의한 호출 (call by reference)을 사용합니다.

`Point` 클래스의 크기가 큰 경우,
 첫 번째 함수에서 `Point` 객체가 복사되어 전달되므로 
 이 과정에서 추가적인 시간과 메모리가 소비됩니다. 반면에 두 번째 함수에서는 포인터만 전달되므로 이러한 오버헤드가 발생하지 않습니다.**

따라서 일반적으로 `Point` 클래스의 크기가 큰 경우, 두 번째 함수가 좀 더 효율적입니다. 
하지만 이 경우에도 원본 객체를 변경하지 않으려면 const 포인터를 사용하는 것이 좋습니다:
*/
